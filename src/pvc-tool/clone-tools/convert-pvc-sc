#!/bin/bash
SCRIPT="$(/usr/bin/readlink -f "${BASH_ARGV0:-${BASH_SOURCE:-${0}}}")"
BASEDIR="$(/usr/bin/dirname "${SCRIPT}")"

set -euo pipefail

[ -v DISABLE_CLONE ] || DISABLE_CLONE=""
case "${DISABLE_CLONE,,}" in
	true | t | yes | y ) DISABLE_CLONE="true" ;;
	* ) DISABLE_CLONE="false" ;;
esac
export DISABLE_CLONE

POD_POLL_WAIT="10"
POD_REBOOT_WAIT="60"
POD_REBOOT_TIMEOUT="$(( POD_REBOOT_WAIT * 15 ))"

timestamp()
{
	/usr/bin/date -Ins
}

say()
{
	echo -e "$(timestamp): ${@}"
}

ok()
{
	say "✅ ${@}"
}

warn()
{
	say "⚠️ ${@}"
}

err()
{
	say "❌ ${@}" 1>&2
}

fail()
{
	err "${@}"
	exit ${EXIT_CODE:-1}
}

is_valid_name()
{
	local NAME="${1}"
	[[ "${NAME}" =~ ^[a-z0-9]([a-z0-9-]*[a-z0-9])?$ ]] || return ${?}
	return 0
}

execute()
{
	#
	# Show the command about to be executed
	#
	say "${@@Q}"
	if "${DISABLE_CLONE}" ; then
		warn "Cloning disabled: skipping the command execution"
		return 0
	fi

	#
	# Proceed with the execution
	#
	( exec "${@}" )
	return ${?}
}

get_deployment_status()
{
	local STATUS=""

	# Have to split this or our logic won't work
	STATUS="$("${HELM}" status "${RELEASE}" --namespace "${NAMESPACE}" -o json)" || return ${?}

	# Can be one of: unknown, deployed, uninstalled,
	# superseded, failed, uninstalling, pending-install,
	# pending-upgrade or pending-rollback
	local RESULT=""
	RESULT="$("${JQ}" -r '.info.status' <<< "${STATUS}")" || return ${?}
	echo -n "${RESULT}"
	return 0
}

should_install()
{
	local STATUS=""
	STATUS="$(get_deployment_status)"
	case "${STATUS,,}" in
		deployed ) return 1 ;;
		* ) return 0 ;;
	esac
}

should_uninstall()
{
	local STATUS=""
	STATUS="$(get_deployment_status)"
	case "${STATUS,,}" in
		uninstalled ) return 1 ;;
		* ) return 0 ;;
	esac
}

is_namespace_exists()
{
	local NAMESPACE="${1}"
	execute "${KUBECTL}" get namespace "${NAMESPACE}" &>/dev/null || return ${?}
	return 0
}

deploy_chart()
{
	should_install || return 0
	execute "${HELM}" install \
		"${RELEASE}" arkcase/pvc-rsync \
		--namespace "${NAMESPACE}" \
		--wait \
		--timeout=30m \
		--set mode=clone || fail "Unable to deploy the chart"
}

wait_until_pod_exists()
{
	local POD="${1}"
	local NEXT_WAIT=${POD_POLL_WAIT}
	local FIRST="true"
	local START="$(/usr/bin/date +%s)"
	local END="$(( START + POD_REBOOT_TIMEOUT ))"
	while true; do
		if ! "${FIRST}" ; then
			# Apply the polling wait ...
			say "💤 Sleeping for ${NEXT_WAIT} before checking for its existence again..."
			/usr/bin/sleep ${NEXT_WAIT} || return ${?}
		fi

		"${KUBECTL}" get pod \
			--namespace "${NAMESPACE}" "${POD}" &>/dev/null && return 0

		"${FIRST}" && warn "The pod ${NAMESPACE}/${POD} doesn't exist yet..."
		FIRST="false"

		local NOW="$(/usr/bin/date +%s)"
		[ $(( NOW - START )) -ge ${POD_REBOOT_TIMEOUT} ] && break
		[ $(( NOW + NEXT_WAIT )) -lt ${END} ] || NEXT_WAIT=$(( END - NOW ))
	done

	# Should never happen, but if it does...
	err "The pod didn't come up in ${POD_REBOOT_TIMEOUT} seconds, can't wait anymore"
	return 1
}

is_pod_terminated()
{
	local POD="${1}"

	local PHASE=""
	PHASE="$(get_pod_phase "${POD}")" || return ${?}

	case "${PHASE,,}" in
		succeeded | failed ) return 0 ;;
		* ) return 1 ;;
	esac
}

wait_until_pod_is_running()
{
	local POD="${1}"
	local NEXT_WAIT=${POD_POLL_WAIT}
	local FIRST="true"
	local START="$(/usr/bin/date +%s)"
	local END="$(( START + POD_REBOOT_TIMEOUT ))"
	while true; do
		if ! "${FIRST}" ; then
			# Apply the polling wait ...
			say "💤 Sleeping for ${NEXT_WAIT} before checking for status again..."
			/usr/bin/sleep ${NEXT_WAIT} || return ${?}
		fi

		local OUT=""
		OUT="$("${KUBECTL}" wait pod \
			--namespace "${NAMESPACE}" "${POD}" \
			--for condition=Ready \
			--timeout="${NEXT_WAIT}s" 2>&1)" && return 0

		# Edge case ...
		is_pod_terminated "${POD}" && return 0

		"${FIRST}" && warn "The pod ${NAMESPACE}/${POD} isn't running yet..."
		FIRST="false"

		local NOW="$(/usr/bin/date +%s)"
		[ $(( NOW - START )) -ge ${POD_REBOOT_TIMEOUT} ] && break
		[ $(( NOW + NEXT_WAIT )) -lt ${END} ] || NEXT_WAIT=$(( END - NOW ))
	done

	# Should never happen, but if it does...
	err "The pod didn't start running in ${POD_REBOOT_TIMEOUT} seconds, can't wait anymore"
	return 1
}

wait_until_pod_terminates()
{
	local POD="${1}"

	local OUT=""
	OUT="$("${KUBECTL}" wait pod \
		--namespace "${NAMESPACE}" "${POD}" \
		--for condition=Ready=false \
		--timeout="2160h" 2>&1)" && return 0

	local RC=${?}
	err "Failed to wait for pod termination (rc=${RC})\n${OUT}"
	return ${RC}
}

track_logs()
{
	local POD="${1}"
	"${KUBECTL}" logs \
		--namespace "${NAMESPACE}" \
		--tail=1000 \
		--ignore-errors \
		--follow "${POD}"
	return ${?}
}

get_pod_phase()
{
	local POD="${1}"

	local OUT=""
	OUT="$("${KUBECTL}" get pod --namespace "${NAMESPACE}" "${POD}" -o jsonpath='{ .status.phase }' 2>&1)"

	local RC=${?}
	[ ${RC} -eq 0 ] && echo -n "${OUT}"
	return ${RC}
}

get_copy_result()
{
	local POD="${RELEASE}-0"

	local POD_STATUS=""
	while true; do
		# Step 1: wait until the pod exists
		wait_until_pod_exists "${POD}" || fail "The pod did not come online"

		if ! is_pod_terminated "${POD}" ; then
			# Step 2: wait until the pod is running
			ok "The pod ${NAMESPACE}/${POD} exists! Waiting for it to be Ready"
			wait_until_pod_is_running "${POD}" || fail "The pod never reached the running state"

			# Step 3: Track the logs, so the user can see what's going on
			ok "The pod ${NAMESPACE}/${POD} is running!"
			say "👀 Tracking the logs for ${NAMESPACE}/${POD}"
			track_logs "${POD}"
			wait_until_pod_terminates "${POD}"
			ok "The pod ${NAMESPACE}/${POD} appears to have completed its work"
		else
			ok "The pod ${NAMESPACE}/${POD} already completed its work"
		fi

		# Step 4: Pod has exited (or somesuch)...get its termination status
		while true ; do
			if POD_STATUS="$(get_pod_phase "${POD}")" ; then
				case "${POD_STATUS,,}" in
					# If it's still running, it means the phase event hasn't
					# propagated yet, so we have to wait a bit...
					running ) sleep 3 ; continue ;;
					succeeded ) return 0 ;;
					failed ) "${KUBECTL}" logs --tail=1000 --namespace "${NAMESPACE}" "${POD}" ; return 1 ;;
					* ) err "Unknown status [${POD_STATUS}], will try to wait for the pod result again" ; continue ;;
				esac
			fi
		done

		# Something's off ... pod exited, but we can't get the status ...
		err "Failed to retrieve the pod status ... will try again"
	done
}

undeploy_chart()
{
	should_uninstall || return 0
	execute "${HELM}" uninstall \
		"${RELEASE}" \
		--namespace "${NAMESPACE}" \
		--wait \
		--timeout=30m \
		--cascade foreground || fail "Unable to undeploy the chart"
}

usage()
{
	echo -e "usage: ${BASH_SOURCE:-${0}} [namespace] release" 1>&2
	exit 1
}

[ ${#} -ge 1 ] && [ ${#} -le 2 ] || usage

HELM="$(type -P helm)" || fail "Could not find helm in the path"
JQ="$(type -P jq)" || fail "Could not find jq in the path"
KUBECTL="$(type -P kubectl)" || fail "Could not find kubectl in the path"

if [ ${#} -eq 1 ] ; then
    NAMESPACE="$("${KUBECTL}" config view --minify -o jsonpath="{..namespace}")"
    [ -n "${NAMESPACE}" ] || NAMESPACE="${POD_NAMESPACE:-default}"
else
    NAMESPACE="${1}"
    shift
fi
is_valid_name "${NAMESPACE}" || fail "Invalid namespace name [${NAMESPACE}]"

RELEASE="${1}"
is_valid_name "${RELEASE}" || fail "Invalid release name [${RELEASE}]"

# If the target namespace doesn't exist, by extension the environment doesn't exist
if ! is_namespace_exists "${NAMESPACE}" ; then
    say "The namespace ${NAMESPACE} does not exist, so nothing to remove"
    exit 0
fi

say "👉 Deploying the chart to do the volume cloning..."
deploy_chart || fail "Couldn't deploy the chart to do the volume cloning"
ok "Chart deployed!"

say "👉 Run the file copy"
get_copy_result || fail "The file copy seems to have failed, please review the full logs for more information"
ok "Copy complete!"

say "👉 Removing the chart to release the volumes..."
undeploy_chart || fail "Couldn't un-deploy the chart"
ok "Undeployment completed!"
