#!/bin/bash
set -euo pipefail
. /.functions

find_schedules()
{
	if [ ${#} -lt 1 ] ; then
		find "${DATA_DIR}" -type f -iname '*.cron'
		return 0
	fi
	for n in "${@}" ; do
		[ -e "${n}" ] || err "File not found: [${n}]"
		[ -f "${n}" ] || err "Not a file: [${n}]"
		readlink -f "${n}"
	done
}

usage()
{
	echo -e "usage: ${BASH_SOURCE:-${0}} [-r | --reset | -h | --help ]" 1>&2
	exit 1
}

[ ${#} -le 1 ] || usage
[ -v RESET ] || RESET="false"
if [ ${#} -eq 1 ] ; then
	case "${1}" in
		--reset | -r ) RESET="true" ; set -- ;;
		* ) usage ;;
	esac
fi

set_as_boolean RESET "${RESET}"

###################################################################
# CONFIGURE FILESYSTEM PERSISTENCE                                #
###################################################################
set_or_default BASE_DIR "/app"
set_or_default DATA_DIR "${BASE_DIR}/data"

require_dir_readwrite "${DATA_DIR}"
export DATA_DIR

INSTALL_LOG="${DATA_DIR}/.cron-install-log"

if "${RESET}" ; then
	say "##############################################"
	say "⚠️ RESETTING THE CRONTAB AND INSTALLATION LOG ⚠️"
	say "##############################################"
	crontab -r
	> "${INSTALL_LOG}"
fi

require_exe run-kjb
export RUN_KJB="$(type -P run-kjb)"

CRONTAB="$(crontab -l 2>/dev/null)" || true
if "${RESET}" || [ -z "${CRONTAB}" ] ; then
	# Initialize the crontab with our nice header
	crontab <<-EOF
	# Example of job definition:
	# .---------------- minute (0 - 59)
	# |  .------------- hour (0 - 23)
	# |  |  .---------- day of month (1 - 31)
	# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
	# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
	# |  |  |  |  |  .- command to run (will usually be run-kjb some-file)
	# |  |  |  |  |  |
	# *  *  *  *  *  ${RUN_KJB} /some/job/file.kjb
	EOF
	ok "Crontab intialized"
	> "${INSTALL_LOG}"
fi

doing "Autodeploying any pending cron schedules..."
# Add all cron schedules that need to be auto-added
touch "${INSTALL_LOG}" || fail "Failed to initialize the cron installation log"
DEPLOYED=0
SKIPPED=0
FAILED=0
INVALID=0
FOUND=0
while read CRON ; do

	(( ++FOUND ))

	# Has this schedule been ingested yet? If so, just skip over it it
	# we DO NOT support dynamic overwriting of old schedules b/c then we
	# could clobber manual administrator tweaks, including disabling jobs
	# that are misbehaving
	while IFS="|" read DATE SUM OLD_CRON ; do
		(( ++SKIPPED ))
		ok "Schedule from [${CRON}] was already installed on ${DATE} (${SUM})"
		# Continue the outer loop
		continue 2
	done < <(sed -e 's;#.*$;;g' -e '/^\s*$/d' < "${INSTALL_LOG}" | egrep "[|]${CRON}$")

	# This is a new schedule, let's ingest it!
	JOB="${CRON%.*}"
	if [ -f "${JOB}" ] ; then
		# Is the job a valid XML file?
		if ! xmllint "${JOB}" &>/dev/null ; then
			(( INVALID++ ))
			err "Ignoring job file with invalid XML: [${JOB}]"
			continue
		fi

		# The job is valid ... is the schedule? Yes, we can have
		# multiple schedules for the same file
		CRONTAB="$(
			crontab -l
			echo -e "\n#\n# BEGIN schedule from [${CRON}]\n#"
			while read M H D T W R ; do
				echo -e "${M}\t${H}\t${D}\t${T}\t${W}\t${RUN_KJB} ${JOB}"
			done < <(sed -e 's;#.*$;;g' -e '/^\s*$/d' < "${CRON}")
			echo -e "#\n# END schedule from [${CRON}]\n#"
		)"

		if OUT="$(crontab <<< "${CRONTAB}" 2>&1)" ; then
			ok "Deployed the schedule for [${JOB}]"
			read SUM REST < <(sha256sum "${CRON}")
			echo -e "$(date -Isec -u)|${SUM}|${CRON}" >> "${INSTALL_LOG}"
			(( ++DEPLOYED ))
		else
			(( ++FAILED ))
			err "FAILED TO DEPLOY THE SCHEDULE FOR [${JOB}] (rc=${?}): ${OUT}"
		fi
	else
		(( ++INVALID ))
		warn "Ignoring a cron schedule without a job file: [${CRON}]"
		continue
	fi

done < <(find_schedules "${@}")
P="s"
[ ${FOUND} -ne 1 ] || P=""
doing "Found ${FOUND} schedule${P} to deploy"
if [ ${FOUND} -gt 0 ] ; then
	[ ${DEPLOYED} -eq 0 ] || ok "${DEPLOYED} deployed"
	[ ${SKIPPED} -eq 0 ] || warn "${SKIPPED} skipped"
	[ ${INVALID} -eq 0 ] || err "${INVALID} invalid"
	[ ${FAILED} -eq 0 ] || err "${FAILED} failed"
fi
ok "Deployment complete"
exit 0
