#!/bin/bash
set -euo pipefail
. /.functions

set_as_boolean DEBUG

cleanup()
{
	[ -v RUN_MARKER ] || RUN_MARKER=""
	[ -z "${RUN_MARKER}" ] || rm -rf "${RUN_MARKER}" &>/dev/null
}

usage()
{
	say "usage: ${BASH_SOURCE:-${0}} lock-marker initializer-process"
}

[ ${#} -ne 2 ] && usage

set_or_default BASE_DIR "/app"
set_or_default LOGS_DIR "${BASE_DIR}/logs"

redirect_logs "${LOGS_DIR}/lock-initializer.log"

[ -v PENTAHO_VERSION ] || fail "The PENTAHO_VERSION variable isn't set, please update your Pentaho container image"

export INIT_MARKER="${1}"
[[ "${INIT_MARKER}" =~ ^[^[:space:]]{32,}$ ]] || fail "The lock-marker parameter must not be empty, may not contain any spaces, and must be at least 32 characters long"
read MARKER_SUM REST < <(echo -n "${INIT_MARKER}" | sha256sum)

export INIT_PROCESS="${2}"
[ -n "${INIT_PROCESS}" ] || fail "The initializer-process parameter may not be the empty string"

export INIT_VERSION="${PENTAHO_VERSION}"

# We have the init version include the hash for the artifacts so we don't deploy
# the new artifacts unless we absolutely have to. This also has a side effect that
# it avoids duplicate installation for the artifacts
set_or_default INIT_DIR "${BASE_DIR}/init"
set_or_default SUMS_FILE "${INIT_DIR}/.artifact-sums"
is_file_readable "${SUMS_FILE}" && ARTIFACTS_HASH="$(<"${SUMS_FILE}")" || ARTIFACTS_HASH=""
[ -n "${ARTIFACTS_HASH}" ] && INIT_VERSION+="-${ARTIFACTS_HASH}"

say "Version info: ${INIT_VERSION}"
say "Process info: ${INIT_PROCESS}"
say "Marker info:  ${#INIT_MARKER}:[${MARKER_SUM}]"

export CURATOR_WRAPPER_JAR="/usr/local/bin/curator-wrapper.jar"
export CURATOR_WRAPPER_CONF="/usr/local/etc/curator-wrapper.yaml"

(
	execute java -Dzookeeper.client.secure=true -jar "${CURATOR_WRAPPER_JAR}" -c "${CURATOR_WRAPPER_CONF}"
)
exit ${?}
