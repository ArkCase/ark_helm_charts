#!/bin/bash
set -euo pipefail
. /.functions

#
# We use ADMIN_PASSWORD as our canary ... if it's not set,
# it's a good indication that we need to try to load the
# runtime environment from the stored file
#
if [ ! -v ADMIN_PASSWORD ] ; then
	# Make sure we test for and read the same file!
	CRON_ENV="${PENTAHO_HOME:-}/.cron-env"
	if is_file_readable "${CRON_ENV}" ; then
		source "${CRON_ENV}"
	fi
fi

usage()
{
	echo -e "usage: ${BASH_SOURCE:-${0}} [-p ... | --param ...] [-c ... | --custom ...] file.kjb"
	exit 1
}

cleanup_logs()
{
	if [ -n "${LOG}" ] && [ -f "${LOG}" ] ; then
		# Compress the newly-produced log, if it exists
		gzip -9 "${LOG}"
	fi
	while read log ; do
		rm -f "${log}" &>/dev/null || true
	done < <(find "${LOGS_DIR}" -type f -name "${JOB_NAME}-*.log.gz" | sort -r | tail -n +$(( LOG_KEEP + 1 )) )
}

is_key_value_pair()
{
	local VAL="${1}"
	[[ "${VAL}" =~ ^[a-zA-Z0-9_]+=.*$ ]] || return 1
	return 0
}

cleanup()
{
	cleanup_logs
}

[ ${#} -ge 1 ] || usage

ARGS="$(getopt -o "hp:c:" -l "help,param:,custom:" -n "${BASH_ARGV0:-${BASH_SOURCE:-${0}}}" -- "${@}" 2>/dev/null)" || usage
eval set -- "${ARGS}"

PARAM=()
CUSTOM=()
while true ; do
	case "${1}" in
		-c | --custom )
			VAL="${2}"
			is_key_value_pair "${VAL}" || fail "The custom value must be given as a KEY=VALUE pair: [${VAL}] is not valid syntax"
			CUSTOM+=(-custom:"${VAL}")
			shift 2
			;;
		-p | --param )
			VAL="${2}"
			is_key_value_pair "${VAL}" || fail "The parameter value must be given as a KEY=VALUE pair: [${VAL}] is not valid syntax"
			PARAM+=(-param:"${VAL}")
			shift 2
			;;
		-h | --help ) usage ;;

		-- ) shift ; break ;;
	esac
done

[ ${#} -eq 1 ] || usage

JOB="${1}"
require_file_readable "${JOB}"
JOB="$(readlink -f "${JOB}")"
JOB_DIR="$(dirname "${JOB}")"
JOB_NAME="$(basename "${JOB}")"

DEFAULT_LOG_KEEP=30
set_or_default LOG_KEEP
[[ "${LOG_KEEP}" =~ ^[1-9][0-9]*$ ]] || LOG_KEEP=${DEFAULT_LOG_KEEP}

set_or_default BASE_DIR "/app"
set_or_default CONF_KJB "config"
set_or_default PENTAHO_PDI_HOME "${BASE_DIR}/pentaho-pdi"

# Ignore the prescribed log directory
export LOGS_DIR="${JOB_DIR}/logs"
ensure_dir "${LOGS_DIR}"

LOG="${LOGS_DIR}/${JOB_NAME}-$(date -u +%Y%m%d-%H%M%S).log"
redirect_logs "${LOG}"
trap cleanup EXIT

# To temporarily disable template rendering, for debugging purposes
set_as_boolean NOTEMPLATES

################################################################################
# Are there any templates to render?
################################################################################
CONF_KJB="${JOB_DIR}/${CONF_KJB}"

if is_dir_readable "${CONF_KJB}" ; then
	say "Found the configuration directory at [${CONF_KJB}]"
	# The config directory should contain a kettle directory
	# with all the files (or templates) that would go in .kettle,
	# and a metastore directory with all the files (or templates)
	# that would go in .pentaho/metastore

	is_dir_readable "${CONF_KJB}/.kettle" && export KETTLE_HOME="${CONF_KJB}"
	is_dir_readable "${CONF_KJB}/metastore" && export JAVA_TOOL_OPTIONS="${JAVA_TOOL_OPTIONS:-} -DPENTAHO_METASTORE_FOLDER=${CONF_KJB}"

else
	say "The configuration directory [${CONF_KJB}] was not found, will not set the KETTLE_HOME and PENTAHO_METASTORE_FOLDER variables"
fi

if [ -v SSL_DIR ] ; then
	export KEYSTORE_PATH="${SSL_DIR}/keystore.pkcs12"
	export KEYSTORE_PASSWORD="$(<"${SSL_DIR}/keystore.pass")"
fi

# Allow rendering to be disabled
if "${NOTEMPLATES}" ; then
	say "Template rendering was disabled"
else
	# This double-check makes it easier to use this script
	# in developers' environments
	require_exe render-template encrypt-passwords

	# Find all the templates within the entire tree,
	# and render the final files.
	#
	# If the found item is a directory, then every file
	# within is processed, and the output goes to the
	# corresponding file within the sibling directory
	# of the same name, minus the "*.tpl" suffix.
	#
	# If the found item is a file, it will be rendered
	# to its corresponding file, minus the "*.tpl" suffix,
	# in the same directory.
	#
	# We're careful here to avoid double-rendering, so
	# first we find all files with the name "*.tpl", but
	# which are NOT within a folder with the name "*.tpl".
	# Then we process the folders with the name "*.tpl",
	# but which are NOT within a folder with the name
	# "*.tpl", and render the files within as described above

	(
		set -euo pipefail

		cd "${JOB_DIR}"

		# Encrypt the passwords, so we don't persist sensitive
		# values to disk unencrypted
		say "Encrypting passwords for Kettle"
		source <(encrypt-passwords kettle) || fail "Failed to encrypt the passwords"

		say "Rendering any necessary templated files"
		# Process the files
		while read SRC ; do
			# Remove the leading "./"
			TGT="${SRC#*/}"
			# Remove the trailing ".tpl"
			TGT="${TGT%.*}"
			say "Rendering [${TGT}]..."
			render-template < "${SRC}" > "${TGT}"
		done < <(find . -type f -iname '*.tpl' -not -ipath '*/*.tpl/*' | sort)

		say "Rendering any necessary templated directories"
		# Process the directories
		while read SRC_DIR ; do
			# Remove the leading "./"
			TGT_DIR="${SRC_DIR#*/}"
			# Remove the trailing ".tpl"
			TGT_DIR="${TGT_DIR%.*}"
			say "Rendering files within [${TGT_DIR}]..."
			while read SRC ; do
				# Remove the leading "./"
				SRC="${SRC#*/}"
				# Pre-pend the target path
				TGT="${TGT_DIR}/${SRC}"
				# Pre-pend the orignal template directory path
				SRC="${SRC_DIR}/${SRC}"
				say "\tRendering [${TGT}]..."
				render-template < "${SRC}" > "${TGT}"
			done < <(cd "${SRC_DIR}" && find . -type f | sort)
		done < <(find . -type d -iname '*.tpl' -not -ipath '*/*.tpl/*' | sort)

		say "Template rendering completed"
	)
fi

LOG_FLAG=()

# Allow the log level to be set via environment variable
[ -v LOG_LEVEL ] && [ -n "${LOG_LEVEL}" ] && LOG_FLAG=("-level:${LOG_LEVEL}")

# If the log level isn't set by environment, then allow
# for it to be set via a companion file?
if [ ${#LOG_FLAG[@]} -eq 0 ] && [ -f "${JOB}.debug" ] ; then
	read LOG_LEVEL REST < <(sed -e 's;#.*$;;g' -e '/^\s*$/d' < "${JOB}.debug" | head -1) || true
	[ -n "${LOG_LEVEL}" ] && LOG_FLAG=("-level:${LOG_LEVEL}")
fi

running "Running the Kettle job from [${JOB}]"
cd "${PENTAHO_PDI_HOME}/data-integration"
RC=0
( execute ./kitchen.sh "${PARAM[@]}" "${CUSTOM[@]}" -file:"${JOB}" "${LOG_FLAG[@]}" < /dev/null ) || RC=${?}
say "Exit Status: [${RC}]"
exit ${RC}
