{{- $db := (include "arkcase.db.info" $ | fromYaml) -}}
{{- $baseUrl := (include "arkcase.tools.parseUrl" (include "arkcase.tools.conf" (dict "ctx" $ "value" "baseUrl")) | fromYaml) -}}
{{- $pdftron := (include "arkcase.license" (dict "ctx" $ "name" "pdftron") | fromYaml) -}}
{{- $aggrid := (include "arkcase.license" (dict "ctx" $ "name" "aggrid") | fromYaml) -}}
{{- with $pdftron.data }}
pdftron:
  {{- if .viewer }}
  viewer.license: {{ .viewer | b64dec | quote }}
  {{- end }}
  {{- if .audioVideo }}
  audioVideo.viewer.license: {{ .audioVideo | b64dec | quote }}
  {{- end }}
{{- end }}

{{- with $aggrid.data }}
aggrid.license: {{ . | b64dec | quote }}
{{- end }}

# This is set to disable the "Snowbound" advert button ... code should be modified to
# not require this (i.e. remove the button altogether)
fileEditingEnabled: true

#
# Begin integrations with external systems
#
{{- include "arkcase.core.integrations.config" $ | nindent 0 }}
#
# End integrations with external systems
#

report:
  plugin:
    # Attempted fix for easier Pentaho integration
    PENTAHO_SERVER_URL: ""
    PENTAHO_SERVER_PORT: 0

    # Use the new service accounts for this, instead of the ArkCase admin user
    PENTAHO_SERVER_USER: "${ARKCASE_REPORTS_ADMIN_USERNAME}"
    PENTAHO_SERVER_PASSWORD: "${ARKCASE_REPORTS_ADMIN_PASSWORD}"

    # This is the internally-visible port where traffic will be proxied to/from
    PENTAHO_SERVER_INTERNAL_URL: "${ARKCASE_REPORTS_URL_SCHEME}://${ARKCASE_REPORTS_URL_HOST}"
    PENTAHO_SERVER_INTERNAL_PORT: "${ARKCASE_REPORTS_URL_PORT}"

{{- $content := (include "arkcase.content.info" $ | fromYaml) }}
{{- if (eq "alfresco" $content.dialect) }}
alfresco:
  admin:
    baseurl: "${ARKCASE_CONTENT_URL}/s/enterprise/admin/admin-sync"
    username: &alfrescoUsername "${ARKCASE_CONTENT_ADMIN_USERNAME}"
    password: &alfrescoPassword "${ARKCASE_CONTENT_ADMIN_PASSWORD}"

  sync:
    protocol: &alfrescoScheme "${ARKCASE_CONTENT_URL_SCHEME}"
    host: &alfrescoHost "${ARKCASE_CONTENT_URL_HOST}"
    port: &alfrescoPort "${ARKCASE_CONTENT_URL_PORT}"
    contextRoot: &alfrescoContext "${ARKCASE_CONTENT_URL_PATH}"
    username: *alfrescoUsername
    password: *alfrescoPassword
    enabled: {{ (not (empty (include "arkcase.toBoolean" $content.sync))) }}

alfresco_protocol: *alfrescoScheme
alfresco_host: *alfrescoHost
alfresco_port: *alfrescoPort
alfresco_contextRoot: *alfrescoContext
alfresco_user: *alfrescoUsername
alfresco_password: *alfrescoPassword
{{- end }}

fileManagement:
  fileRepositoryType: {{ $content.dialect | quote }}
{{- if (eq "s3" $content.dialect) }}
  s3:
    url: "${ARKCASE_CONTENT_URL}"
    region: "${ARKCASE_CONTENT_REGION}"
    bucketName: "${ARKCASE_CONTENT_BUCKET}"
    accessKey: "${ARKCASE_CONTENT_USERNAME}"
    secretKey: "${ARKCASE_CONTENT_PASSWORD}"
{{- end }}

{{- if (eq "box" $content.dialect) }}
  {{- $cmInfo := (.Files.Get "cminfo.yaml" | fromYaml) }}
  {{- $privateKeyPath := dig "private-key" "path" "/app/home/.content-private-key" $cmInfo }}
  box:
    privateKeyPath: {{ $privateKeyPath | quote }}
{{- end }}

{{- if (eq "alfresco" $content.dialect) }}
  alfresco:
    url: "${ARKCASE_CONTENT_URL}"
    username: "${ARKCASE_CONTENT_USERNAME}"
    password: "${ARKCASE_CONTENT_PASSWORD}"
{{- end }}

database:
  platform: "org.eclipse.persistence.platform.database.${ARKCASE_JDBC_PLATFORM}Platform"
  # Should this be "true" when SSL is active?
  encryption_enabled: true
  encryption_supported: true

acm:
  driverClassName: "${ARKCASE_JDBC_DRIVER}"
  url: "${ARKCASE_JDBC_URL}"
  # schema: "${ARKCASE_JDBC_SCHEMA}"
  username: "${ARKCASE_JDBC_USERNAME}"
  password: "${ARKCASE_JDBC_PASSWORD}"

# Which are the allowed values here?
activiti.db.type: "${ARKCASE_JDBC_WORKFLOW_DB_TYPE}"

onlyoffice.plugin:
  arkcase.baseurl: &baseUrl {{ $baseUrl.url | quote }}

solr:
  protocol: "${ARKCASE_SOLR_URL_SCHEME}"
  host: "${ARKCASE_SOLR_URL_HOST}"
  port: "${ARKCASE_SOLR_URL_PORT}"
  # TODO: support Solr authentication
  # username: "${ARKCASE_SOLR_URL_USERNAME}"
  # password: "${ARKCASE_SOLR_URL_PASSWORD}"
  zkHosts: "${ZK_HOST}"

acm.websockets:
  stomp_broker_relay:
    relay_protocol: "${ARKCASE_MQ_STOMP_URL_SCHEME}"
    relay_host: "${ARKCASE_MQ_STOMP_URL_HOST}"
    relay_port: "${ARKCASE_MQ_STOMP_URL_PORT}"
    client_login: &stompUsername "${ARKCASE_MQ_USERNAME}"
    client_passcode: &stompPassword "${ARKCASE_MQ_PASSWORD}"
    system_login: *stompUsername
    system_passcode: *stompPassword
    # Make sure we use the keystore on the filesystem
    keystore: "file:${JAVA_KEYSTORE}"
    keystore_type: "${JAVA_KEYSTORE_TYPE}"
    keystore_pass: "${JAVA_KEYSTORE_PASS}"
    # Make sure we use the truststore on the filesystem
    truststore: "file:${JAVA_TRUSTSTORE}"
    truststore_type: "${JAVA_TRUSTSTORE_TYPE}"
    truststore_pass: "${JAVA_TRUSTSTORE_PASS}"

acm.hazelcast:
  log.folder: "${LOGS_DIR}"
  # Temporarily disable hazelcast diagnostics
  diagnostics.enabled: false
  network:
    port: 5710
    port.auto_increment: false
  kubernates:
    namespace: {{ $.Release.Namespace | quote }}
    serviceName: {{ include "arkcase.service.headless" $ | quote }}

{{ include "arkcase.core.email" $ }}

application:
  properties:
    baseUrl: *baseUrl
{{- $saml := (include "arkcase.core.sso.saml" $ | fromYaml) }}
{{- if $saml }}
    logoutUrl: /saml/logout
{{- end }}

  rolesToGroups: {{- include "arkcase.core.rolesToGroups" $ | nindent 4 }}

notification:
  arkcase.port: {{ $baseUrl.port }}
  arkcase.url: {{ printf "%s://%s" $baseUrl.scheme $baseUrl.hostname | quote }}
  arkcase.url.base: {{ $baseUrl.url | quote }}

ocr:
  tempPath: "${TEMP_DIR}/ocr"

################################################################################
#
# New configurations for the new discoverable component types like the content
# store, temp file store, and upload service
#
################################################################################

component:
  #
  # NOTE: For some reason Springs dynamic Binder doesn't like camelCase property names,
  # so we had to modify them to be kebab-case ... this sucks, but we'll find a fix for
  # it later on, if it becomes an actual problem
  #

  leased-locks:
    lease:
      # Other type: jvm
      type: "jpa"
      minimum-duration: "1m"
      default-duration: "15m"
      maximum-duration: "8h"
    thread-lock:
      # Other types: jvm, curator
      type: "hazelcast"

  content:
    internal: &internal-content
      type: "s3"
      endpoint: "${ARKCASE_INTERNAL_CONTENT_URL}"
      region: "${ARKCASE_INTERNAL_CONTENT_REGION}"
      bucket: "${ARKCASE_INTERNAL_CONTENT_BUCKET}"
      prefix: "internal"
      credentials:
        type: "static"
        access-key-id: "${ARKCASE_INTERNAL_CONTENT_USERNAME}"
        secret-access-key: "${ARKCASE_INTERNAL_CONTENT_PASSWORD}"
    ecm:
      type: "ecmfile"

  temporary-data:
    clustered:
      <<: *internal-content
      prefix: "temporary"
    local:
      base-path: "${TEMP_DIR}/content"

  upload:
    <<: *internal-content
    prefix: "uploads"