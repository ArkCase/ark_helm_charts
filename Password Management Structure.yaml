Templates: |-
  // Render the name the configured secret/configMap for the given subsystem and value type
  //   - If a subsystem name is not given, the current subsystem's name will be used where appropriate
  //   - If a type is not given, use the default type of either "conn", "cred-admin", or "cred-access"
  //     will be used, computed based on the template called (i.e. if the template has "conn", "admin",
  //     or "cred" in the name)
  arkcase.subsystem-access.name.conn(subsys?)
  arkcase.subsystem-access.name.admin(subsys?)
  arkcase.subsystem-access.name.cred(subsys?, type?)

  // Render only one envvar reference, including the secret/configMap name, saved into the given envVar name
  //   - If a subsystem name is not given, the current subsystem's name will be used where appropriate
  //   - If a type is not given, use the default type of either "conn" or "cred-access" will be used, computed
  //     based on the template called (i.e. if the template has "conn" or "cred") in the name
  //   - The key will be referenced directly, and is the only required parameter
  //       - The key will have any mappings applied to it as necessary and stipulated in the configuration in order
  //         to arrive at the final key in the final object that the value is to be retrieved from
  //       - The key must be a valid configMap/secret key (i.e. ^[a-z0-9_.-]+$)
  //       - When analyzing the configuration, key mappings will also be validated against this regex
  //   - If the name is not given, generate it based on this pattern "arkcase_[${subsys}_]${type}_${key}"
  //       - If no subsystem name was expressly given, or it matches the local subsystem, then no subsys component will be added
  //       - The generated variable name will be all-uppercase by default
  //       - This also means that "local" envvars will have the "arkcase_" prefix regardless
  //   - If the name parameter is given, then...
  //       - The name parameter may also include these placeholders:
  //           ${subsys} == subsystem name (current or targeted)
  //           ${type} == extra information describing what the key is about (will never be empty)
  //           ${key} == the key itself, verbatim, with dots and dashes replaced with underscores
  //       - These value substitutions may have the suffix :u for uppercase, or :l for lowercase
  //       - Substituted values with no case specifier will be uppercased by default
  //       - The name parameter must be a valid BASH variable name (i.e. match /^[a-zA-Z0-9_]+$/)
  //   - If optional is not given, use the default value of "false" (boolean)
  //   - The target object kind will also depend on whether the object is expressly referenced, or if
  //     the template called had "conn" (configMap) or "cred" (secret) in the name. As ever, it must
  //     exist in the current namespace

  // Produce an env declaration for the specific value that reads from the source resource
  arkcase.subsystem-access.env.conn(subsys?, key, name?, optional?)
  arkcase.subsystem-access.env.admin(subsys?, key, name?, optional?)
  arkcase.subsystem-access.env.cred(subsys?, type?, key, name?, optional?)

  // Produce a volumeMount entry for the specific value that links to the source resource
  arkcase.subsystem-access.volumeMount.conn(subsys?, key, mountPath?, optional?)
  arkcase.subsystem-access.volumeMount.admin(subsys?, key, mountPath?, optional?)
  arkcase.subsystem-access.volumeMount.cred(subsys?, key, type?, mountPath?, optional?)

  // Produce a volume entry for the specific value that mounts the source resource
  arkcase.subsystem-access.volume.conn(subsys?)
  arkcase.subsystem-access.volume.admin(subsys?)
  arkcase.subsystem-access.volume.cred(subsys?, type?)

  - Envvar names will be uppercased unless expressly defined to not be by way of the name parameter, regardless
    of what the source secret/configMap YAML has defined

  - CamelCase is acceptable in key names (the name must be specified directly), but generally discouraged


  // Produce the full configuration for the subsystem - useful for quick analysis
  arkcase.subsystem-access.conf(subsys?)
  arkcase.subsystem.conf(subsys?)

  // Produce the name of the resource ... should only be used to render said resource
  arkcase.subsystem-access.name.conn(subsys?)
  arkcase.subsystem-access.name.admin(subsys?)
  arkcase.subsystem-access.name.cred(subsys?, type?)

  - Example default resource names (all secrets by default)
    ${release}-${subsys}-conn // the connection information
    ${release}-${subsys}-cred-admin // the admin credentials
    ${release}-${subsys}-cred-access // the access credentials
    ${release}-${subsys}-cred-access-${account} // account credentials
    ${release}-${subsys}-cred-schema-${account} // account credentials for Database schema access

# The "mappings" entry is so we can support secrets with keys
# different to our own.  The ${myKeyX} names are known key names
# supported by the subsystem, while the ${targetKeyX} values are
# the keys in the target entity that actually house those values
#
# These mappings will be handled when rendering the environment
# variable mappings and whatnot to interact with the subsystem,
# and should be totally transparent to the chart developer.
#
# Deployers do need to specify these mappings when needed (i.e.
# to interact with RDS resources and whatnot). They may also
# have to provide the secrets/configmaps with those settings
# applied manually if they're not being rendered.

global:
  conf:
    acme:
      settings:
        # TODO: Plan out cert-manager support, since we'll need
        #         - a certificate for each pod that works for them individually,
        #           but also any service they share
        #             - Render keystores with these as needed
        #             - Render HAProxy certs with these as needed
        #         - the trust-manager ca.pem and cacerts to be trusted
        #         - Will need to be able to specify the issuer, possibly per-subsystem?
        # dialect: (default|cert-manager)
        # ...
        # Other various settings

      # The "connection:" item describes where the connection
      # information is stored. By default, it'll be in a generated configMap,
      # but can also be provided in other secrets for external services
      connection:
        # Only one of secret: or configmap: are allowed
        secret: ${secretName}
        configMap: ${configMapName}
        mapped-keys:
          mapKey1: targetKey1
          mapKey2: targetKey2
          # ...

      # The "credentials:" item describes where the credentials
      # information is stored for different uses. By default
      # they will be stored in generated secrets, and most likely
      # may also include the connectivity information (i.e. host,
      # port, protocol, etc.)
      credentials:

        # Short form (i.e. no mappings, for briefer syntax):
        # access: ${secretName}
        access:
          secret: ${secretName}
          mapped-keys: ...

    ldap:
      settings:
        # other various non-connectivity settings

      connection:
        # Only one of secret: or configMap: are allowed
        secret: ${secretName}
        configMap: ${configMapName}
        mapped-keys: ...

      credentials:
        # Abbreviated version:   admin: ${secretName}
        admin:
          secret: ${secretName}
          mapped-keys: ...

        # Abbreviated version:   access: ${secretName}
        access:
          secret: ${secretName}
          mapped-keys: ...

    reports:
      settings:
        # other various non-connectivity settings

      connection:
        # Only one of secret: or configMap: are allowed
        secret: ${secretName}
        configMap: ${configMapName}
        mapped-keys: ...

      credentials:
        admin:
          secret: ${secretName}
          mapped-keys: ...

        access:
          secret: ${secretName}
          mapped-keys: ...

    content:

      settings:
        # other various non-connectivity settings
        dialect: (s3|alfresco)

      connection:
        # Only one of secret: or configMap: are allowed
        secret: ${secretName}
        configMap: ${configMapName}
        mapped-keys: ...

      credentials:
        admin:
          secret: ${secretName}
          mapped-keys: ...

        access:
          secret: ${secretName}
          mapped-keys: ...

    messaging:
      settings:
        # other various non-connectivity settings

      # DEFAULT CONFIGMAP: ${release}-messaging-conn
      connection:
        # Only one of secret: or configMap: are allowed
        secret: ${secretName}
        configMap: ${configMapName}
        mapped-keys: ...

      credentials:
        admin:
          secret: ${secretName}
          mapped-keys: ...

        arkcase:
          secret: ${secretName}
          mapped-keys: ...

        cloudconfig:
          secret: ${secretName}
          mapped-keys: ...

        experimental:
          secret: ${secretName}
          mapped-keys: ...

    rdbms:
      settings:
        # other various non-connectivity settings
        dialect: (mysql|psql|oracle|mssql|db2|...)

      # DEFAULT CONFIGMAP: ${release}-rdbms-conn
      connection:
        # Only one of secret: or configMap: is allowed
        secretRef: ${secretName}
        configMapRef: ${configMapName}

        mapped-keys: ...

      credentials:
        # Abbreviated version:   admin: ${secretName}
        # DEFAULT SECRET: ${release}-rdbms-admin
        admin:
          secret: ${secretName}
          mapped-keys: ...

        # DEFAULT SECRET: ${release}-rdbms-schema-${schemaName}
        schema:
          # Abbreviated version:   arkcase: ${secretName}
          arkcase:
            secret: ${secretName}
            mapped-keys: ...

          # Abbreviated version:   pentaho: ${secretName}
          pentaho:
            secret: ${secretName}
            mapped-keys: ...


---

#
# This is an example secret from an RDS installation
#
apiVersion: v1
kind: Secret
metadata:
  name: rds-secret-example
type: Opaque
data:
  endpoint: dGVzdDEtcmRzLmNsaGV2dnlyOGlwaC51cy1lYXN0LTEucmRzLmFtYXpvbmF3cy5jb20=
  port: MzMwNg==
  password: UE1lZ0FXTVNlZW50RllLdlE0UEZnQWEzelF1
  username: YWRtaW4=

#
# This is an example configuration for the admin integration for that secret
#
global:
  conf:
    rdbms:
      settings:
        # other various non-connectivity settings
        dialect: (mysql|psql|oracle|mssql|db2|...)

      # DEFAULT CONFIGMAP: ${release}-rdbms-conn
      connection:
        # Only one of secret: or configMap: is allowed
        secretRef: rds-secret-example
        mapped-keys:
          # The "hostname" key would map to the "endpoint" key
          hostname: endpoint

---
standard-connectivity-configurations:
  acme:
    settings:
      dialect: step-ca|acme|cert-manager
      # Possibly more settings? Maybe the issuer name for CM, etc?
    connection:
      url: ...
    credentials:
      access:
        password: ...

  analytics:

  content:
    settings:
      dialect: s3|alfresco
      # Possibly more settings? Like Alfresco noindex, etc?
    connection:
      url: ...
      ui: ...
    credentials:
      admin:
        username:
        password:
      access:
        username:
        password:

  ldap:
    connection:
      url: ...
    credentials:
      admin:
        username:
        password:
      access:
        username:
        password:

  messaging:
    connection:
      url: ...
    credentials:
      admin:
        username:
        password:
      access-arkcase:
        username:
        password:
      access-cloudconfig:
        username:
        password:
      access-experimental:
        username:
        password:

  rdbms:
    settings:
      dialect: mysql|psql|mssql|oracle|...
      # Possibly more settings?
    connection:
      host: ...
      port: ...
    credentials:
      admin:
        username:
        password:
      schema-arkcase:
        username:
        password:
        realname:
      schema-pentaho:
        username:
        password:
        realname:
      schema-pentaho-jcr:
        username:
        password:
        realname:
      schema-pentaho-quartz:
        username:
        password:
        realname:

  reports:
    connection:
      url: ...
    credentials:
      admin:
        username:
        password:
      access:
        username:
        password:

  search:
    connection:
      url: ...
    # Not necessary yet
    credentials:
      admin:
        username:
        password:
      access:
        username:
        password:

  zookeeper:
    connection:
      hosts: ...
    # Not necessary yet
    credentials:
      admin:
        username:
        password:
      access:
        username:
        password:
---
pseudo-logic: |
  $credentialTypesToProvision := []

  // If we weren't given external connection information, everything is rendered and provisioned internally
  if (connection not provided)
  {
    - render connection
    - render all admin secrets
    - render all credentials secrets
    - render the complete embedded subsystem
    - provision all accounts as needed since we have total control

    - env macros render values
    - volumeMount macros render value mounts
    - volume macros render volumes

    // For each credentials available
    for (credential in credentialTypes)
    {
      $credentialTypesToProvision += $credential

      - render credentials secret
      - credentials volumeMount macro renders the value mounts
      - credentials volume macro renders the volume
    }
  }
  else
  {
    // We were given external connection information, so consume it!
    - connection env macro can render the values
    - connection volumeMount macro can render the value mounts
    - connection volume macro can render the volume

    if (admin provided)
    {
      - admin env macro can render the values
      - admin volumeMount macro can render the value mounts
      - admin volume macro can render the volume
    }
    else
    {
      - do not render admin secret

      - admin env macro can render empty (random?) values
      - admin volumeMount macro can not render the value mounts (?)
      - admin volume macro can not render the volume (?)
    }

    // For each credentials available
    for (credential in credentialTypes)
    {
      // If we are given a type, we don't care and we use that
      if (credentials[$credential] provided)
      {
        - credentials env macro renders the value for type
        - credentials volumeMount macro renders the value mount for type
        - credentials volume macro renders the volume for type

        continue;
      }

      // If we're not given a type, we may still have received admin credentials... so
      // use them to provision a new account in the remote service
      if (admin provided)
      {
        $credentialTypesToProvision += credentials[$credential]
        - render credentials secret

        - credentials volumeMount macro renders the value mounts
        - credentials volume macro renders the volume

        continue;
      }

      // Here, we have neither admin creds to provision accounts with, or account creds to consume to access
      // the target accounts ... this is a misconfiguration

      fail KABOOM! - can't provision b/c no admin, can't access b/c no creds given, and this is an illegal configuration
    }
  }

  if (not empty $credentialTypesToProvision)
  {
    for (credential in $credentialTypesToProvision)
    {
      - using the admin creds, compute the necessary provisioning information to create and/or update the credentials
    }

    - render the embedded subsystem's credential-account provisioning bits, to consume this provisioning information
  }
